import socket
import subprocess
import ping3
import concurrent.futures
from scapy.all import ARP, Ether, srp
from scapy.layers.l2 import getmacbyip
from pysnmp.hlapi import *
import concurrent.futures

#CODED BY SID4HACK---------------------------------------->>>>>>>>

def ping_device(ip):
    print(f"Pinging {ip}...")
    try:
        result = subprocess.run(['ping', '-c', '1', ip], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, timeout=5)
        if result.returncode == 0:
            print(f"Ping successful for {ip}")
            return ip
        else:
            print(f"Ping failed for {ip}")
            return None
    except subprocess.TimeoutExpired:
        print(f"Ping timeout for {ip}")
        return None
    except Exception as e:
        print(f"Error pinging {ip}: {e}")
        return None

def get_private_ip():
    try:
        # Get the local hostname
        hostname = socket.gethostname()

        # Get the IP address associated with the hostname
        private_ip = socket.gethostbyname(hostname)

        return private_ip
    except Exception as e:
        print(f"Error occurred: {e}")
        return None

def map_network_topology(ip):
    topology = {}
    errorIndication, errorStatus, errorIndex, varBinds = next(
        getCmd(SnmpEngine(),
               CommunityData('public', mpModel=0),
               UdpTransportTarget((ip, 161),timeout=5),
               ContextData(),
               ObjectType(ObjectIdentity('SNMPv2-MIB', 'sysDescr')))
    )
    if errorIndication:
        print(f"Error: {errorIndication}")
        return topology
    if errorStatus:
        print(f"Error: {errorStatus}")
        return topology
    else:
        description = varBinds[0][1].prettyPrint()
        if 'router' in description.lower():
            topology['Type'] = 'Router'
        elif 'switch' in description.lower():
            topology['Type'] = 'Switch'
        else:
            topology['Type'] = 'Host'
    return topology

def scan_device(ip):
    arp_packet = Ether(dst="ff:ff:ff:ff:ff:ff") / ARP(pdst=ip)
    result = srp(arp_packet, timeout=2, verbose=False)[0]
    for sent, received in result:
        mac = received.hwsrc
        vendor = getmacbyip(ip) if ip != socket.gethostbyname(socket.gethostname()) else "Your Device"
        services = enumerate_services(ip)
        topology = map_network_topology(ip)
        return {'IP': ip, 'MAC': mac, 'Vendor': vendor, 'Services': services, 'Topology': topology}

def enumerate_services(ip, ports=None):
    services = {}

    if ports is None:
        # Default list of common ports to scan
        ports = [21, 22, 23, 25, 53, 80, 443, 3389]

    for port in ports:
        try:
            # Create a socket and attempt to connect
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.settimeout(2)  # Set a timeout for the connection attempt
                result = s.connect_ex((ip, port))

                if result == 0:
                    service_name = socket.getservbyport(port)
                    services[port] = service_name
        except Exception as e:
            print(f"Error scanning {ip}:{port}: {e}")

    return services

def ping_device(ip):
    response_time= ping3.ping(ip)  # Set ICMP ping timeout to 1 second
    if response_time is not None:
        return ip
    return None

def ping_device(ip):
    print(f"Pinging {ip}...")
    response_time = ping3.ping(ip)  # Set ICMP ping timeout to 1 second
    if response_time is not None:
        print(f"Ping successful for {ip} (Response Time: {response_time} ms)")
        return ip
    else:
        print(f"Ping failed for {ip}")
        return None


def scan_local_network():
    local_ip = get_private_ip()
    local_subnet = '.'.join(local_ip.split('.')[:-1])
    ip_range = [f"{local_subnet}.{i}" for i in range(1, 255)]

    responsive_ips = []

    with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:
        future_to_ip = {executor.submit(ping_device, ip): ip for ip in ip_range}
        for future in concurrent.futures.as_completed(future_to_ip):
            ip = future_to_ip[future]
            try:
                result = future.result()
                if result:
                    responsive_ips.append(result)
            except Exception as e:
                print(f"Error pinging {ip}: {e}")

    return responsive_ips

def identify_device_type(ip):
    if ip.endswith('.1'):
        return 'Router'
    elif ip.endswith('.2'):
        return 'Switch'
    else:
        return 'Host'

if __name__ == "__main__":
    private_ip = get_private_ip()
    if private_ip:
        print(f"Private IP Address: {private_ip}")

    responsive_ips = scan_local_network()

    devices = []
    with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:
        future_to_ip = {executor.submit(scan_device, ip): ip for ip in responsive_ips}
        for future in concurrent.futures.as_completed(future_to_ip):
            ip = future_to_ip[future]
            try:
                result = future.result()
                if result:
                    devices.append(result)
            except Exception as e:
                print(f"Error scanning {ip}: {e}")
    

for device in devices:
        device_ip = device['IP']
        device_mac = device['MAC']
        device_vendor = device['Vendor']
        device_type = identify_device_type(device_ip)
        services = device['Services']
        topology = device['Topology']
        print(f"IP Address: {device_ip} | MAC Address: {device_mac} | Vendor: {device_vendor} | Device Type: {device_type}")
        for port, service in services.items():
            print(f"  Port: {port} | Service: {service}")
        if 'Type' in topology:
            print(f"  Topology: {topology['Type']}")
